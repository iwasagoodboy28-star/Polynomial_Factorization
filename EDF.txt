def fasterpowermod1(a,q,b): #a^q mod b
    ans=1
    while q>=1:
        if q%2==1:#展開の位の数が1なら積を計算する
            #print('ans',ans)
            ans*=a.mod(b)
        a=(a^2).mod(b) #2乗の計算
        q=q//2
    return ans.mod(b)

def random(deg): #Fp上のランダム多項式deg(h)<degを返す
    while(1):
        h_tmp=0
        deg_h=randint(1,deg-1) #次数指定
        for i in range(deg_h+1):
            h_tmp+=randint(0,p-1)*x^i
        if h_tmp!=h_tmp.constant_coefficient(): #hが定数でないものを返す
            return h_tmp


def FindNonTrivialFactor(f,d):
    q=(p^d-1)//2
    while(1):
        h=random(f.degree()) #ランダム多項式を生成
        g=gcd(h,f)
        if g!=1:
            return g,f//g
        f1=gcd(fasterpowermod1(h,q,f)-1,f) #h^q-1 mod y とfとのgcd ユークリッドの定理
        if f1!=1 and f1!=f:
            return f1,f//f1
    
def EDF(f,d):
    SF=[]
    F=[f]
    while(len(SF)<(f.degree()//d)):
        g=F[0]#先頭要素
        F.remove(g) #使用した多項式を削除
        #if g.degree()!=0: #gが定数でなければ非自明因子計算に入る
        g1,g2=FindNonTrivialFactor(g,d)
        if  g1.degree()!=d:
            F.append(g1)
        else:
            SF.append(g1)
        if  g2.degree()!=d:
            F.append(g2)
        else:
            SF.append(g2)
    return SF
        

    
p=3
R.<x> = PolynomialRing(GF(p))
print(EDF(x^2+2,1))
print(EDF(x^4+x^3+x+2,2))


